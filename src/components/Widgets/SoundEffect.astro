<script>
const soundTypes = {
  click: 'tap',
  typing: 'type',
} as const

type SoundType = typeof soundTypes[keyof typeof soundTypes]

const volumeSettings: Record<SoundType, number> = {
  [soundTypes.click]: 0.8,
  [soundTypes.typing]: 0.4,
}

const clickTargets = [
  '#language-switcher',
  '#theme-toggle-button',
  '#mobile-language-switcher',
  '#mobile-theme-toggle',
  '#mobile-menu-toggle',
] as const

const typingTargets = [
  // Twikoo
  '.el-input__inner',
  '.el-textarea__inner',
  // Waline
  '#wl-nick',
  '#wl-mail',
  '#wl-link',
  '#wl-edit',
] as const

const ignoredKeys = new Set([
  'Shift',
  'Control',
  'Alt',
  'Meta',
  'Tab',
  'Escape',
  'CapsLock',
])

const clickSelector = clickTargets.join(',')
const typingSelector = typingTargets.join(',')

function isMobileDevice(): boolean {
  return window.matchMedia('(max-width: 1023px)').matches
}

function getBasePath(): string {
  const sitemap = document.head.querySelector('link[rel="sitemap"]')
  const href = sitemap?.getAttribute('href')
  return href?.replace('/sitemap-index.xml', '') || ''
}

class SoundEffectManager {
  private audioContext: AudioContext | null = null
  private audioBuffers: Record<SoundType, AudioBuffer[]> = {
    [soundTypes.click]: [],
    [soundTypes.typing]: [],
  }

  private initPromise: Promise<void> | null = null

  // Fetch, decode and cache a single sound file
  private async fetchAndCacheSound(type: SoundType, index: number): Promise<void> {
    if (!this.audioContext) {
      throw new Error('Audio context not initialized')
    }

    const soundId = `${type}_0${index + 1}`
    const response = await fetch(`${getBasePath()}/sounds/${soundId}.wav`)
    const arrayBuffer = await response.arrayBuffer()
    const audioBuffer = await this.audioContext.decodeAudioData(arrayBuffer)
    this.audioBuffers[type].push(audioBuffer)
  }

  // Preload all sound variants
  private async preloadAllSounds(): Promise<void> {
    const soundTypeValues = Object.values(soundTypes) as SoundType[]
    const allPromises = soundTypeValues.flatMap(type =>
      Array.from({ length: 5 }, (_, i) => this.fetchAndCacheSound(type, i)),
    )

    await Promise.allSettled(allPromises)
  }

  // Initialize audio context and preload sound files (executes only once)
  private async initialize(): Promise<void> {
    return this.initPromise ??= (async () => {
      try {
        this.audioContext = new (window.AudioContext || window.webkitAudioContext)()
        await this.preloadAllSounds()
      }
      catch (error) {
        console.warn('[Sound] Failed to initialize sound effects:', error)
      }
    })()
  }

  // Play a random sound variant for the given type
  public async playSound(type: SoundType): Promise<void> {
    if (!this.audioContext) {
      await this.initialize()
    }

    if (!this.audioContext || this.audioBuffers[type].length === 0) {
      return
    }

    try {
      const randomIndex = Math.floor(Math.random() * this.audioBuffers[type].length)
      const buffer = this.audioBuffers[type][randomIndex]

      const source = this.audioContext.createBufferSource()
      const gainNode = this.audioContext.createGain()

      source.buffer = buffer
      gainNode.gain.value = volumeSettings[type]

      source.connect(gainNode)
      gainNode.connect(this.audioContext.destination)

      source.start()
    }
    catch (error) {
      console.warn('[Sound] Failed to play sound:', error)
    }
  }
}

// Global sound manager instance
const soundManager = new SoundEffectManager()

// Handle click sound effects (now includes mobile buttons)
function handleClickSound(e: Event): void {
  // Play sounds on all devices, not just desktop
  const target = e.target as Element
  if (target?.closest(clickSelector)) {
    soundManager.playSound(soundTypes.click)
  }
}

// Handle typing sound effects
function handleTypingSound(e: KeyboardEvent): void {
  if (isMobileDevice() || ignoredKeys.has(e.key)) {
    return
  }

  const target = e.target as Element
  if (target?.matches(typingSelector)) {
    soundManager.playSound(soundTypes.typing)
  }
}

// Bind event listeners
document.addEventListener('click', handleClickSound, { passive: true })
document.addEventListener('keydown', handleTypingSound, { passive: true })
</script>
